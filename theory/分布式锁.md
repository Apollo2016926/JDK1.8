# <center>分布式锁</center>

### 简介

为了保证一个方法或属性在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLock或Synchronized)进行互斥控制。在单机环境中，Java中提供了很多并发处理相关的API。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题！

### 什么是分布式锁

- 当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。
- 与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠。。。一个大坑）
- 分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。。

### 分布式锁应具备的条件

+ 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行

+ 高可用的获取锁与释放锁

+ 高性能的获取锁与释放锁

+ 具备可重入特性（可理解为重新进入，由多于一个任务并发使用，而不必担心数据错误）

+ 具备锁失效机制，防止死锁

+ 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失

  ### 应用方式 

+ [基于数据库实现分布式锁](https://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&mid=2247483982&idx=1&sn=305e22c0e74a028cb9180ac03bd110fa&scene=21#wechat_redirect)；

+ [基于缓存（Redis等）实现分布式锁](https://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&mid=2247483993&idx=1&sn=f6b408b01e10a2ab75256acf07e08537&scene=21#wechat_redirect)；

+  [基于Zookeeper实现分布式锁](https://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&mid=2247483988&idx=1&sn=9e29b4aa64becd7d7764062dc5389eed&scene=21#wechat_redirect)； 

  

   

   

   